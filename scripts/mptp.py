from os import path
import numpy as np

def parse( file_path ):
  result = dict()
  species_count = 0

  from collections import defaultdict
  delim_map=defaultdict(list)

  reading_taxa=False
  cur_cluster=0
  for line in open ( file_path ):
    parts = line.split( ":" )

    if parts[0].startswith( "Null-model score" ):
      result["null_model_score"] = float(parts[1])
    elif parts[0].startswith( "Best score for multi coalescent rate" ):
      result["multi_coalescent_score"] = float(parts[1])
    elif parts[0].startswith( "Number of delimited species" ):
      result["species_count"] = int(parts[1])
    elif parts[0].startswith( "Species" ):
      species_count += 1
      cur_cluster=int(parts[0].split(' ')[1])
      reading_taxa=True
    elif reading_taxa:
      taxon=parts[0].rstrip().rsplit( "_" )[0]
      if len(taxon) != 0:
        delim_map[ cur_cluster ].append(taxon)

  # check if everything is there
  if not "species_count" in result:
    raise RuntimeError( "Could not detect species_count in mptp result file: {}".format(filepath) )
  if not "null_model_score" in result:
    raise RuntimeError( "Could not detect null_model_score in mptp result file: {}".format(filepath) )
  if not "multi_coalescent_score" in result:
    raise RuntimeError( "Could not detect multi_coalescent_score in mptp result file: {}".format(filepath) )

  # check if species count makes sense
  if result["species_count"] != species_count:
    raise RuntimeError( "Inconsistent species count in file: {}".format(filepath) )

  result["delimitation"]=dict(delim_map)

  return result

# takes a list of mptp results (as generated by 'parse') and summarizes them into comprehensive metrics
def summarize( results ):
  summary = dict()

  species_counts = []
  null_model_scores = []
  multi_coalescent_scores = []

  for result in results:
    species_counts.append( result["species_count"] )
    null_model_scores.append( result["null_model_score"] )
    multi_coalescent_scores.append( result["multi_coalescent_score"] )

  summary["count_average"] = np.mean(species_counts)
  summary["count_median"] = np.median(species_counts)
  summary["count_stdev"] = np.std(species_counts)

  summary["null_score_average"] = np.mean(null_model_scores)
  summary["null_score_median"] = np.median(null_model_scores)
  summary["null_score_stdev"] = np.std(null_model_scores)

  summary["multi_score_average"] = np.mean(multi_coalescent_scores)
  summary["multi_score_median"] = np.median(multi_coalescent_scores)
  summary["multi_score_stdev"] = np.std(multi_coalescent_scores)

  return summary





# /*
#  * Parse a mptp result file into the internal format
#  */
# delimit_result parse( std::string const& result_file )
# {
#   delimit_result result;

#   result.fname_ = result_file;

#   std::ifstream infile( result_file );

#   size_t num_species = 0;

#   for ( std::string line; std::getline(infile, line); ) {
#     auto parts = split(line, ":");
#     // skip lines that contain no information
#     if ( parts.empty() ) {
#       continue;
#     }

#     if        ( starts_with( parts[0], "Species " ) ) {
#       result.species_.emplace_back( parse_species( infile ) );
#     } else if ( starts_with( parts[0], "Null-model score" ) ) {
#       result.null_model_score_ = std::stod( parts.at(1) );
#     } else if ( starts_with( parts[0], "Best score for multi coalescent rate" ) ) {
#       result.multi_score_ = std::stod( parts.at(1) );
#     } else if ( starts_with( parts[0], "Number of delimited species" ) ) {
#       num_species = std::stoi( parts.at(1) );
#     }

#   }

#   if ( num_species != result.species_.size() ) {
#     throw std::runtime_error( std::string("inconsistent species count: ")
#       + to_string(num_species) + " vs. " + to_string(result.species_.size()) );
#   }

#   return result;
# }